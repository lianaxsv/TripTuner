rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // USERS COLLECTION
    match /users/{userId} {
      allow read: if request.auth != null;
      allow write: if request.auth != null && request.auth.uid == userId;
      
      // User's liked itineraries subcollection
      match /likedItineraries/{itineraryId} {
        allow read, write: if request.auth != null && request.auth.uid == userId;
      }
      
      // User's saved itineraries subcollection
      match /savedItineraries/{itineraryId} {
        allow read, write: if request.auth != null && request.auth.uid == userId;
      }
      
      // User's completed itineraries subcollection
      match /completedItineraries/{itineraryId} {
        allow read, write: if request.auth != null && request.auth.uid == userId;
      }
    }

    // HANDLES COLLECTION
    match /handles/{handle} {
      allow read: if request.auth != null;
      allow create: if request.auth != null 
        && !exists(/databases/$(database)/documents/handles/$(handle));
      allow update: if request.auth != null 
        && request.resource.data.uid == request.auth.uid;
      allow delete: if request.auth != null 
        && resource.data.uid == request.auth.uid;
    }

    // ITINERARIES COLLECTION
    match /itineraries/{itineraryId} {
      // Anyone authenticated can read all itineraries (for map display)
      allow read: if request.auth != null;
      
      // Anyone authenticated can create itineraries
      // BUT they can only set authorID to their own UID
      allow create: if request.auth != null 
        && request.resource.data.authorID == request.auth.uid;
      
      // Only the author can update their own itinerary
      allow update: if request.auth != null 
        && resource.data.authorID == request.auth.uid
        && request.resource.data.authorID == request.auth.uid;
      
      // Only the author can delete their own itinerary
      allow delete: if request.auth != null 
        && resource.data.authorID == request.auth.uid;
      
      // Likes subcollection - anyone can read, authenticated users can write
      match /likes/{likeId} {
        allow read: if request.auth != null;
        allow write: if request.auth != null;
      }
      
      // Comments subcollection
      match /comments/{commentId} {
        // Anyone authenticated can read comments
        allow read: if request.auth != null;
        
        // Anyone authenticated can create comments
        allow create: if request.auth != null 
          && request.resource.data.authorID == request.auth.uid;
        
        // Allow updates:
        // 1. Author can update their own comment (any field)
        // 2. Any authenticated user can update the score field (for voting)
        allow update: if request.auth != null && (
          resource.data.authorID == request.auth.uid ||
          request.resource.data.diff(resource.data).affectedKeys().hasOnly(['score'])
        );
        
        allow delete: if request.auth != null 
          && resource.data.authorID == request.auth.uid;
        
        // Votes subcollection - users can read/write their own votes
        // The document ID is the userId, so users can only write to their own vote
        match /votes/{userId} {
          allow read: if request.auth != null;
          allow write: if request.auth != null && request.auth.uid == userId;
        }
      }
    }
  }
}

